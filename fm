#!/bin/bash
# shellcheck disable=SC2015,SC2172,SC2128,SC2207
# SC2207 -- Prefer mapfile or read -a to spli... breaks reverse
# SC2128 -- Expanding an array without an ind... oh convenient
# SC2172 -- Trapping signals by number is not... trap -l is ez
# SC2015 -- Note that A && B || C is not if-t... duh

LC_ALL=C
LANG=C

set -o ignoreeof

trap end 2
trap 'init_term; draw_files' 28

init_term()
{
shopt -s checkwinsize; (:;:)
((rows=LINES-1))

printf '\e[?1049h\e[2J\e[1;%dr\e[%dH\e[?7l\e[?25l' \
  "$LINES" "$rows"
}; init_term

end(){ printf '\e[?1049l\e[?7h\e[?25h'&& exit; }

clear_screen(){ printf '\e[2J\e[%dH' "$rows"; }

read_keys()
{
read -rsn1 key
[[ $key == $'\e' ]]&& read -rsn2 key
key="${key^^}"
}

change_dir()
{
clear_screen
if [[ $marked == '*' ]]; then
  cd -
  unset status mark
else
  cd "${1:-$marked}"|| return
fi
get_files&& cursor="$rows"
}

keymap()
{
read_keys
case $key in
  Q) end;;
  D) printf '\e[H\e[2K%s' 'New directory name: '

    read -r
    mkdir "$REPLY"&&{
      status='created' mark="4m$REPLY\e[m/"
      get_files
    }||{
      status='error' mark="4m$REPLY\e[m/ exist"
      hud
    }
  ;;
  F) printf '\e[H\e[2K%s' 'New file name: '

    read -r
    :>"$REPLY"&&{
      mark="9m$REPLY" status='created'
      get_files
    }||{
      status='error' mark="9m$REPLY exist"
      hud
    }
  ;;
  X|\[3) [[ $marked ]]&&{
    printf '\e[H\e[2K%b' \
      "Do you want to delete \e[3$mark\e[m? [y/n]: "

    read -rsn1
    [[ ${REPLY,,} == 'y' ]]&&{
      del="$path/$marked"
      rm -fr "${del:?Not found}"&& status='deleted'

      [[ $marked == "${PWD##*/}" ]]&&
        change_dir ../|| get_files
    }|| printf '\e[2K'
  }
  ;;
  H|\[D) change_dir ../;;
  J|\[B) ((cursor++));;
  K|\[A) ((cursor--));;
  L|''|\[C) status='marked' path="$PWD"
    mark="${files[$cursor-$LINES]}"
    marked="${mark#[0-9]*m}" marked="${marked%\\e[m?}"

    #
    
    change_dir||{
      printf '\e[?1049l'
      clear_screen&& cat "$marked"
      status='viewing'&& hud

      for((;;)){
        read_keys
        case $key in
          Q) end;;
          H|\[D) status='marked'&& get_files&& break;;
          L|\[C) "${VISUAL:-${EDITOR:-vi}}" "$marked";;
        esac
      }

      printf '\e[?1049h\e[?25l'
      clear_screen&& draw_files; hud
    }
  ;;
esac
}

reverse(){
local -n foo="$1"

shopt -s extdebug

bar()( printf '%s\n' "${BASH_ARGV[@]}" )
foo=($(bar "${foo[@]}"))
unset "foo[-1]"

shopt -u extdebug
}

get_files()
{
unset files

IFS=$'\n'
for fp in "$PWD"/*; do
  file="${fp##*/}"

  if [[ -h $fp ]]; then
    [[ $TERM =~ 256 ]]&& color='8;5;42'|| color='6;1'
    file+='\e[m@'
  elif [[ -f $fp&& -x $fp|| $fp == *'.sh' ]]; then
    [[ $TERM =~ 256 ]]&& color='8;5;210'|| color='2;1'
    file+='\e[m*'
  elif [[ -d $fp ]]; then
    [[ $TERM =~ 256 ]]&& color='8;5;147'|| color='4;1'
    file+='\e[m/'
  else
    [[ $TERM =~ 256 ]]&& color='8;5;248'|| color='7;2'
  fi

  files+=("${color}m$file") 
done
reverse files
filesBackup=("${files[@]}") fileCount="${#filesBackup[@]}"

draw_files
}

draw_files()
{
clear_screen
printf '\e[3%b\n' "${files[@]}"
hud
}

cursor()
{
(( fileCount > rows ))&&{
  if (( ${#files[@]} > rows&& cursor < 1 )); then
    cursor="$rows"
    files=("${files[@]:0:${#files[@]}-$rows}")
    draw_files
  elif (( cursor > rows )); then
    cursor=1
    files=("${filesBackup[@]:0:${#files[@]}+$rows}")
    draw_files
  fi
  (( rows-cursor == ${#files[@]} ))&& cursor="$rows"
}||{
  ((cursorMin=LINES-fileCount))
  if (( cursor > rows )); then
    cursor="$cursorMin"
  elif (( cursor < cursorMin )); then
    cursor="$rows"
  fi
}

printf '\e[%dH\e[4%b\e[m' "$cursor" "${files[$cursor-$LINES]}"

hist+=("$cursor"); (( cursor == hist ))||
  printf '\e[%dH\e[3%b\e[m' "$hist" "${files[$hist-$LINES]}"
(( i ))&& hist=("${hist[@]:1}")|| i=1
}

hud()
{ 
printf '\e[%dH\e[44mfm\e[m%s\e[3%b %s' "$LINES" \
  "${status:+ ${status^} : }" "${mark:-  }" '[←]back [→]open [q]uit'
}

get_files
for((;;)){
  cursor 2>/dev/null
  keymap
}
